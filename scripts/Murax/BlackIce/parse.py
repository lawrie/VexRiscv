#!/usr/bin/env python3

periphs = dict()
periph_out_pins = dict()
periph_in_pins = dict()

periph_types = ["cpu", "sram", "jtag", "gpio", "uart", "timer", "pwm",
                "tone", "spiMaster", "i2c", "shiftIn", "shiftOut", "pulseIn",
                "sevenSegment", "machineTimer", "ps2", "quadrature",
                "servo", "ws2811", "qspiAnalog", "mux", "pinInterrupt"]

include_periphs = ["shiftIn", "shiftOut", "quadrature", "tone", "ps2",
                   "qspiAnalog", "sevenSegmentA", "sevenSegmentB", "spiMaster", "i2c"]

width_periphs = ["pwm", "pulseIn", "servo", "pinInterrupt", "gpioA", "gpioB"]

standard_params = ["name", "type", "address", "width"]

cpu_attributes = ["coreFrequency", "onChipRamSize", "onChipRamHexFile", "ioAddress",
                   "ramAddress"]

scala_config = list()
verilog_config = list()
variant_h = list()
io_h = list()
assign_vh = list()

gpio_A_width = 0

# Convert camel case identifier to capitals with underscores
def toUpper(str):
  res = ""
  for c in str:
    if c.isupper():
      res +=  "_" + c
    else:
      res += c.upper()
  return res

# Parse file into dictionary of dictionaries 
def parse_cfg(f):
  for line_str in f:

    if len(line_str) == 0 or line_str[0] == "\n":
      pass      
    else:
      line = line_str.split()

      if "#" in line:
        line = line[0:line.index("#")]

      if len(line) == 0 or line[0].startswith("#"):
        continue

      if line_str[0] != " ":  # Peripheral entry
        assert len(line) < 3
        periph_type = line[0]
        assert periph_type in periph_types

        periph_name = line[1] if len(line) > 1 else ""
        assert len(periph_name) == 0 or periph_name == "A" or periph_name == "B"

        cp = {
          "name": periph_name,
          "type": periph_type,
          "address": None,
          "width": None,
        }

        assert periph_type in periph_types

        periphs[periph_type + periph_name] = cp

      elif line[0] == "input" or line[0] == "output" or line[0] == "inout":
        temp = line[1].split("=")
        if len(temp) == 2:
          cp[line[0] + " " + temp[0]] = temp[1] + "".join(line[2:])
        else: # Special case for gpio
          cp[line[0] + " " +  temp[0]] = "".join(line[1:])
      else:
        params = line[0].split("=")
        assert len(params) > 1
        param = params[1]
        if len(line) > 2:
          param += " " + " ".join(line[1:])
        elif len(line) == 2:
          param += " " + line[1]

        if periph_type == "cpu":
          assert params[0] in cpu_attributes

        cp[params[0]] = param

def write_outfile_list(filename, data, comment_start = None):
  with open(filename, "w") as f:
    if comment_start is not None:
      print("%s #### This file is auto-generated by MuraxArduino. Do not edit! ####" % comment_start, file=f)
      print("", file=f)
    for line in data:
      print(line, file=f)

scala_config.append("""
package vexriscv.demo

import spinal.core._

// MuraxArduino Blackice test configuration
object MuraxBlackiceTest{
  def main(args: Array[String]) {
    SpinalVerilog(MuraxArduino(MuraxArduinoConfig.default(false, 0x80000000l).copy(
""")

variant_h.append("""
#ifndef _f32c_variant_h
#define _f32c_variant_h

#include <stdint.h>

/* LEDs */
#define PIN_LED_13           3
#define PIN_LED              3
#define LED_BUILTIN          3

#include "Arduino.h"
#ifdef __cplusplus
#include "UARTClass.h"
#endif

#ifdef __cplusplus
extern UARTClass Serial;
#endif

/*
 * Analog pins - currently dummies to make thing compile
 */
static const uint8_t A0  = 16;
static const uint8_t A1  = 17;
static const uint8_t A2  = 18;
static const uint8_t A3  = 19;
static const uint8_t A4  = 20;
static const uint8_t A5  = 21;
""")

io_h.append("""
#ifndef _IO_H_
#define	_IO_H_

#ifdef __riscv
#include <riscv/io.h>
#endif
""")

assign_vh.append("""
// GPIO and Mux assignments
""")

# Parse the config file
with open("config.txt", "r") as f:
    parse_cfg(f)

# Get gpioA width
if "gpioA" in periphs:
  gpio_A_width = periphs["gpioA"]["width"]

# Generate base addresses in io.h
io_base = "0x0"
ram_base = "0x0"

if "ioAddress" in periphs["cpu"]:
  io_base = periphs["cpu"]["ioAddress"]
  ram_base = periphs["cpu"]["ramAddress"]

io_h.append("""
#define RAM_BASE %s
""" % ram_base)

io_h.append("""
#define IO_BASE %s

#define	IO_ADDR(a)	(IO_BASE | (a))
""" % io_base)

# Generate address offsets in io.h
for periph in periphs:
  if periph != "sram" and "address" in periphs[periph] and periphs[periph]["address"] != None:
    io_h.append("#define IO_" + toUpper(periph) + " IO_ADDR(" + periphs[periph]["address"] + ")")

if "uart" in periphs:
  io_h.append("""
#define	IO_SIO_BYTE	(IO_UART + 0)
#define	IO_SIO_STATUS	(IO_UART + 4)
#define	IO_SIO_BAUD	(IO_UART + 8)
""")

if "gpioA" in periphs:
  io_h.append("""
#define	IO_GPIO_A_INPUT	(IO_GPIO_A + 0)
#define	IO_GPIO_A_DATA	(IO_GPIO_A + 4)
#define	IO_GPIO_A_CTL	(IO_GPIO_A + 8)
""")

if "gpioB" in periphs:
  io_h.append("""
#define	IO_GPIO_B_INPUT	(IO_GPIO_B + 0)
#define	IO_GPIO_B_DATA	(IO_GPIO_B + 4)
#define	IO_GPIO_B_CTL	(IO_GPIO_B + 8)
""")

if "pwm" in periphs:
  io_h.append("""
#define	IO_PWM_DUTY	(IO_PWM + 0)
""")

if "pulseIn" in periphs:
  io_h.append("""
#define	IO_PULSE_IN_VALUE	(IO_PULSE_IN + 0)
#define	IO_PULSE_IN_TIMEOUT	(IO_PULSE_IN + 4)
#define	IO_PULSE_IN_LENGTH	(IO_PULSE_IN + 8)
""")

if "tone" in periphs:
  io_h.append("""
#define	IO_TONE_PERIOD		(IO_TONE + 0)
#define	IO_TONE_DURATION	(IO_TONE + 4)
""")

if "shiftIn" in periphs:
  io_h.append("""
#define	IO_SHIFT_IN_BYTE_VALUE	(IO_SHIFT_IN + 0)
#define	IO_SHIFT_IN_PRE_SCALE	(IO_SHIFT_IN + 4)
#define	IO_SHIFT_IN_BIT_ORDER	(IO_SHIFT_IN + 8)
""")

if "shiftOut" in periphs:
  io_h.append("""
#define	IO_SHIFT_OUT_BYTE_VALUE	(IO_SHIFT_OUT + 0)
#define	IO_SHIFT_OUT_BIT_ORDER	(IO_SHIFT_OUT + 4)
#define	IO_SHIFT_OUT_PRE_SCALE	(IO_SHIFT_OUT + 8)
""")

if "qspiAnalog" in periphs:
  io_h.append("""
#define IO_ANALOG IO_QSPI_ANALOG
""")

if "pinInterrupt" in periphs:
  io_h.append("""
#define IO_PIN_INTERRUPT_RISING  (IO_PIN_INTERRUPT + 0)
#define IO_PIN_INTERRUPT_FALLING  (IO_PIN_INTERRUPT + 4)
#define IO_PIN_INTERRUPT_PENDING  (IO_PIN_INTERRUPT + 0x10)
#define IO_PIN_INTERRUPT_MASKS  (IO_PIN_INTERRUPT + 0x14)
""")

if "timer" in periphs:
  io_h.append("""
#define IO_TIMER_INTERRUPT_MASKS (IO_TIMER_INTERRUPT + 0x14)
""")

# Generate cpu parameters in config.scala
for param in periphs["cpu"]:
  if not param in standard_params and param != "ramAddress" and not param.startswith("input"):
    if periphs["cpu"][param] != None:
      scala_config.append("      " + param + " = " + periphs["cpu"][param] + ",")

# Generate sram parameters in config.scala
for param in periphs["sram"]:
  if param == "address" or not param in standard_params:
    if not(param.startswith("input") or param.startswith("output") or param.startswith("inout")):
      value = periphs["sram"][param]
      if value != None:
        param = "sram" + param[0].upper() + param[1:]
        scala_config.append("      " + param + " = " + value + ",")

# Generate include parameters in config,scala
for periph in periphs:
  if periph in include_periphs:
    present = "true" if periphs[periph] != None else "false"
    scala_config.append("      include" + periph[0].upper() + periph[1:] + " = " + present + ",")

# Generate width parameters in config.scala
for periph in periphs:
  if periph in width_periphs and "width" in periphs[periph] and periphs[periph]["width"] != None:
    scala_config.append("      " + periph + "Width = " + periphs[periph]["width"] + ",")

# Generate maxWs2811leds parameter in config.scala
if "ws2811" in periphs and "maxLeds" in periphs["ws2811"] and periphs["ws2811"]["maxLeds"] != None:
  scala_config.append("      maxWs2811Leds = " + periphs["ws2811"]["maxLeds"] + ",")
  
# Generate includes in config.vh
for periph in periphs:
  if periph != "sram" and "address" in periphs[periph] and periphs[periph]["address"] != None:
    scala_config.append("      " + periph + "Address = " + periphs[periph]["address"] +  ",")
    verilog_config.append("`define INCLUDE_" + toUpper(periph))

verilog_config.append("")

variant_h.append("""
// Other pins
""")

# Generate pin numbers in variant.h
for periph in periphs:
  if periph == "cpu" or periph == "jtag" or periph == "sram":
    continue
  for x in periphs[periph]:
    if x.startswith("input") or x.startswith("output"):
      temp = x.split()
      direction = temp[0]
      pin = temp[1]
      param = periphs[periph][x]
      ports = param.split(",")
      if (len(ports) > 1 or ":" in ports[0]):
        pin_numbers = []
        ports.reverse()
        for port in ports:
          if not "GPIO" in port:
            pin_numbers.append(-1)
          else:
            temp = port.split("]")
            temp = temp[0]
            temp = temp.split("[")
            port_type = temp[0]
            temp = temp[1].split(":")
            if len(temp) == 1:
              pin_number = temp[0]
              pin_number = int(pin_number) if port_type != "GPIOB" else str(int(gpio_A_width) + int(pin_number))
              pin_numbers.append(int(pin_number))
            else:
              i = int(temp[1])
              while i <= int(temp[0]):
                pin_number = i
                pin_number = int(pin_number) if port_type != "GPIOB" else str(int(gpio_A_width) + int(pin_number))
                pin_numbers.append(int(pin_number))
                i  += 1
        if direction == "output":
          pin_numbers.reverse()
          if periph in periph_out_pins: 
            periph_out_pins[periph].append([pin, pin_numbers])
          else:
            periph_out_pins[periph] = [[pin, pin_numbers]]
        elif direction == "input":
          pin_numbers.reverse()
          if periph in periph_in_pins: 
            periph_in_pins[periph].append([pin, pin_numbers])
          else:
            periph_in_pins[periph] = [[pin, pin_numbers]]
        text = "static const int8_t " + toUpper(periph) + "_" + toUpper(pin) + "[] = {"
        pin_numbers.reverse()
        for num in pin_numbers:
          text += str(num)
          text += ","
        text = text[0:len(text)-1]
        text += "};"
        variant_h.append(text)
      else:
        port = ports[0].split("[")
        if port != None and len(port) > 1:
          port_type = port[0]
          port = port[1].split("]")
          pin_number = port[0]
          pin_number = pin_number if port_type != "GPIOB" else str(int(gpio_A_width) + int(pin_number))
          if direction == "output":
            if periph in periph_out_pins:
              periph_out_pins[periph].append([pin, [int(pin_number)]])
            else:
              periph_out_pins[periph] = [[pin, [int(pin_number)]]]
          elif direction == "input":
            if periph in periph_in_pins:
              periph_in_pins[periph].append([pin, [int(pin_number)]])
            else:
              periph_in_pins[periph] = [[pin, [int(pin_number)]]]
          variant_h.append("static const uint8_t " + toUpper(periph) + "_" + toUpper(pin) + " = " + pin_number + ";")

if "spiMaster" in periphs:
  variant_h.append("""
#define SPI_SCLK SPI_MASTER_SCLK
#define SPI_MOSI SPI_MASTER_MOSI
#define SPI_MISO SPI_MASTER_MISO
#define SPI_SS SPI_MASTER_SS
#define SPI_START_PIN SPI_SCLK

""")

variant_h.append("""
// Muxes
""")

print(periph_in_pins)

# Generate mux numbers in config.vh and variant.h
for periph in periphs:
  if "mux" in periphs[periph]:
    if periph == "pwm":
      muxes = periphs[periph]["mux"].split(",")
      muxes.reverse()
      for i in range(len(muxes)):
        verilog_config.append("`define MUX_" + toUpper(periph) + "_" + str(i) + " " + muxes[i])
    else:
      verilog_config.append("`define MUX_" + toUpper(periph) + " " + periphs[periph]["mux"])
      variant_h.append("static const uint8_t " + toUpper(periph) + "_MUX = " + periphs[periph]["mux"] + ";")

for i in range(int(gpio_A_width)):
   found = False
   for periph in periph_out_pins:
     if periph != "pwm":
       x = periph_out_pins[periph]
       for y in x:
         mux = periphs[periph]["mux"]
         if i in y[1]:
           sub = "" if len(y[1]) == 1 else "[" + str(y[1].index(i)) + "]" 
           if not found: 
             assign_vh.append("assign gpioA_write[" + str(i) + "] =   io_mux_pins[" + str(mux) + "] ? io_" +
                              periph + "_" + y[0] + sub)
           else:
             assign_vh.append("                          : io_mux_pins[" + str(mux) + "] ? io_" +
                              periph + "_" + y[0] + sub)
           found = True
   if not found:    
     assign_vh.append("assign gpioA_write[" + str(i) + "] =   io_gpioA_write[" + str(i) + "];")
   else:
     assign_vh.append("                          : io_gpioA_write[" + str(i) + "];")

assign_vh.append("")

for i in range(32, 49):
   found = False
   for periph in periph_out_pins:
     if periph != "pwm":
       x = periph_out_pins[periph]
       for y in x:
         mux = periphs[periph]["mux"]
         if i in y[1]:
           sub = "" if len(y[1]) == 1 else "[" + str(y[1].index(i)) + "]" 
           if not found: 
             assign_vh.append("assign gpioB_write[" + str(i-32) + "] =   io_mux_pins[" + str(mux) + "] ? io_" +
                              periph + "_" + y[0] + sub)
           else:
             assign_vh.append("                          : io_mux_pins[" + str(mux) + "] ? io_" +
                              periph + "_" + y[0] + sub)
           found = True
   if not found:    
     assign_vh.append("assign gpioB_write[" + str(i-32) + "] =   io_gpioB_write[" + str(i-32) + "];")
   else:
     assign_vh.append("                          : io_gpioB_write[" + str(i-32) + "];")

assign_vh.append("""
// GPIO read assignments
""")

for i in range(int(gpio_A_width)):
   for periph in periph_in_pins:
     x = periph_in_pins[periph]
     for y in x:
       if i in y[1]:
         sub = "" if len(y[1]) == 1 else "[" + str(y[1].index(i)) + "]" 
         assign_vh.append("assign " + "io_" + periph + "_" + y[0] + sub + " = gpioread[" + str(i) + "]")

# Generate trailers for each file
scala_config.append("""
      pipelineDBus          = true,
      pipelineMainBus       = false,
      pipelineApbBridge     = true
    )))
  }
}
""")

variant_h.append("""
static const uint8_t PWM_MUX = 6;

#endif /* _f32c_variant_h */
""")

io_h.append("""
#define IO_TIMER_INTERRUPT (RAM_BASE + 0x2000)
#define IO_PIN_INTERRUPT_ADDR (RAM_BASE + 0x2004)

/* SIO status bitmask - TODO: get rid of this */
#define	SIO_TX_BUSY	0x4

#endif /* !_IO_H_ */
""")

assign_vh.append("""
assign gpioA_writeEnable =  io_gpioA_writeEnable;
assign gpioB_writeEnable =  io_gpioB_writeEnable[16:0];

assign io_gpioA_read = gpioA_read;
assign io_gpioB_read[16:0] = gpioB_read;
""")

# Write out the files
write_outfile_list("config.scala", scala_config)
write_outfile_list("config.vh", verilog_config)
write_outfile_list("variant.h", variant_h)
write_outfile_list("io.h", io_h)
write_outfile_list("assignments.vh", assign_vh)

